# Getter와 Setter

### :rocket: 무분별한 getter와 setter 사용을 피하자
public 인스턴스 변수만 있는 클래스와  
private 인스턴스 변수를 가지고 public으로 설정된 getter와 setter를 가진 클래스는 서로 똑같다
```java
// Car1.java

public class Car1 {
    public Engine engine;
}


// Car2.java

public class Car2 {
    private Engine engine;

    public Engine getEngine() {
        return engine;
    }

    public void setEngine(Engine engine) {
        this.engine = engine;
    }
}
```
여기서 Car1이 할 수 있는 어떤 행위든 Car2도 똑같이 할 수 있다는 것이다  

Car2의 private 인스턴스 변수인 Engine 또한 public `getter/setter`로 인해 특정 필드가 있다고 알려주는 셈이며,  
외부에서 마음대로 할 수 있기에 역시 안전하지 않다  
-> **캡슐화(encapsulation)를 무너뜨리게 된다**  

외부에서 getXXX, setXXX 메서드 사용으로 객체 내 필드를 세팅해달라, 얻어와달라고 요청하면 안된다  
해당 객체 자체가 책임을 가지고 있어야 한다

`setXXX()`처럼 의미가 불명확한 메서드명으로 하지말고 차라리 `changeName()`, `changeTitle()`처럼  
메서드이름만 봐도 알 수 있게 작성하는 것이 낫다

반면 상태가 아닌 동작을 노출하도록 만들면 변경에 대한 유연성을 걱정할 필요가 없어지게 된다  

<br>

### :full_moon: 데이터 추상화
객체지향 시스템의 기본 원칙은 객체가 구현 세부 사항을 노출해선 안된다

만약 `getX()`메서드를 1000번 호출하여 각각의 호출에 대해 특정 유형의 반환 값을 지역 변수에 저장하려 했을 때,  
변수의 유형은 반환 값 유형과 반드시 같아야만 한다  
그러나 `X`의 타입을 변경하는 것 처럼 객체 구현 방식을 변경할 필요가 생긴다면?

`X`가 int 였지만, 현재 long으로 바꾼다고 했을 때 1000개의 컴파일 오류가 생긴다

이런 경우 각각 1000번 호출하는 코드를 수정해야만 한다  

여기서 한 클래스의 상수 필드가 아닌 모든 인스턴스 변수를 private으로 만들어야 하는 이유가 있다
- 인스턴스 변수를 `public`으로 만든다면 차후에 이 클래스의 필드를 수정할 수 없게 될 수도 있다
- 해당 필드를 사용하는 외부 코드에 영향을 줄 수 있어 이걸 사용하고 있는 1000개의 코드를 일일히 찾아다녀야 한다

  - 이처럼 **구현 은닉의 원칙(implementation hiding principle)** 은 이 클래스의 객체를 사용하는  
    다른 어떠한 코드에도 영향을 주지 않고도 변경을 가할 수 있는지와 같이 객체지향 시스템의 품질에 대한 엄격한 검사를 가능하게 해준다  
  - 이러한 모듈화가 객체 지향의 핵심 전제이자 유지 보수를 쉽게 만들어준다  

위와 같은 이유로 접근자(accessor)라고 하는 **`getter/setter`** 메서드들은 public 필드가 보여주는 위험성과 마찬가지의 이유로 위험하다  
public상태의 접근자들은 외부에서 상세한 구현 내부로 접근할 수 있게 해주기 때문이다  

> 프로그램 내 어떤 객체가 메시지를 처리하는 구현 부분은 그 프로그램의 나머지 부분으로부터 완전히 감춰져야 한다



어떻게 할 것인가보다 무엇을 할 것인가에 집중하여 설계함으로써 대부분의 `getter/setter`메서드가 제거 될 수 있다

- 수행할 작업에 필요한 정보를 찾지 말고, 그 작업을 수행할 `정보를 가지고 있는 객체`를 찾아라  
클래스 계층에 대한 디자인을 시작하고 그 때 동적인 모델에 클래스들을 끼워 맞추는 방식으로 접근하지 않아야한다  
결국 객체 간 연관관계는 하나의 클래스 객체가 다른 클래스의 객체에 **메시지**를 보내는 두 클래스 관계이기 때문이다  


- 명확하게 정의된 동적 모델이 없다면 추측에 의한 설계 전략(design-by-guessing-strategy)으로 가게 된다  
클래스의 객체가 어떻게 사용될지 몰라 접근자 메소드의 필요 여부에 대한 예측을 할 수 없게 되어  
모델에 대한 접근을 가능한 많이 제공해야만 하는 상황이 오게된다 -> 결국 모델이 엉망이 되어버린다! 

<br>

### :earth_americas: Draw thyself

모든 필드를 캡슐화 하는 한 방법은 사용자 인터페이스(UI) 생성자를 사용하는 것이다   
접근자를 사용할 수 없다면 **UI builder class**로 `getAttribute()`메서드를 호출하도록 만들 수 없다  
하지만 클래스에 `drawYourself(..)` 메소드와 같은 구성 요소를 둘 수 있을 것이다  

만약 `getIdentity()`처럼 get으로 시작하더라도 **단순히 필드만을 반환하지 않고**    
**알맞은 행위를 가지고 있는 복잡한 객체를 반환**한다면 이는 접근자가 아니라고 할 수 있다

<br>

### :jack_o_lantern: 어느 경우에 접근자를 사용하는가

객체가 구현하고 있는 인터페이스를 나타내고 있는 객체를 반환하는 메소드의 경우는 괜찮다  
왜냐하면 이 인터페이스는 클래스 구현의 변경으로 인한 영향을 주지 않기 때문이다

**인터페이스 레퍼런스를 반환하는 이러한 메소드는 실제로 단지 필드에 대한 접근만을 제공하는 메소드라는 의미를 지닌 `getter`가 아니다**

만약 제공자의 내부 구현이 변경된다면 변경 사항을 수용하도록 반환되는 객체의 정의만 수정하면 된다    
해당 인터페이스를 통해 객체를 사용하는 외부 코드는 여전히 변경되지 않아도 된다  


<br>

### :mag_right: Getter/Setter 없이 어떻게 설계하는가

객체지향 설계 과정은 어떠한 유용한 결과를 가져다 주는 독립된 작업(task)을 사용자가 수행하는 `use case`를 중심에 두고 있다  
그 후 객체지향 시스템은 `use case`를 구성하는 다양한 시나리오를 풀어내기 위해 필요한 활동들을 구현한다  
객체들은 다른 `use case`로 **메시지를 전송**함으로써 `use case`를 수행한다  

> 다만 객체와 클래스를 사용하는 절차적인 프로그램을 구축했다면 객체지향과는 멀어지게 될 것이다  

때문에 초창기에는 설계 방법 중 **CRC(classes, responsibilities, collaboration)카드** 기법이 있다  
CRC카드의 집합은 프로그램의 정적 모델이며 전체적인 대화를 통해(객체간 메시지를 주고받는) 발생한 기록은 프로그램의 동적 모델이다  

<br>

### :clipboard: Summing up

- 절대적으로 필요한 경우가 아니라면 접근자`getter/setter`메소드를 사용하지 말자  

**이러한 메소드들은 클래스가 구현되어 있는 방식에 관한 정보를 노출해 결과적으로 코드의 유지 보수를 더 어렵게 만들기 때문이다**  
이를 어렵게 만드는 절차적 사고 방식을 없애는 가장 좋은 방법은 잘 정의된 책임을 가진 객체들 간의 대화에 관해 생각하는 것이다 --> `메시지`


참고 :  
- [https://www.infoworld.com/article/2073723/why-getter-and-setter-methods-are-evil.html](https://www.infoworld.com/article/2073723/why-getter-and-setter-methods-are-evil.html)
  - 위 참고글의 번역본 [https://kldp.org/files/setter__getter_______________________176.pdf](https://kldp.org/files/setter__getter_______________________176.pdf)
- [https://shanepark.tistory.com/323](https://shanepark.tistory.com/323)